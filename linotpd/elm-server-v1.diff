Description: <short description, required>
 <long description that can span multiple lines, optional>
Author: <name and email of author, optional>
Origin: <upstream|backport|vendor|other>, <URL, required except if Author is present>
Bug: <URL to the upstream bug report if any, implies patch has been forwarded, optional>
Bug-<Vendor>: <URL to the vendor bug report if any, optional>
Forwarded: <URL|no|not-needed, useless if you have a Bug field, optional>
Applied-Upstream: <version|URL|commit, identifies patches merged upstream, optional>
Reviewed-by: <name and email of a reviewer, optional>
Last-Update: <YYYY-MM-DD, last update of the meta-information, optional>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/config/who.ini
+++ b/config/who.ini
@@ -1,38 +1,3 @@
-[plugin:form]
-#use = repoze.who.plugins.form:make_redirecting_plugin
-use = linotp.lib.repoze_identify:make_redirecting_plugin
-login_form_url = /account/login
-login_handler_path = /account/dologin
-logout_handler_path = /account/logout
-rememberer_name = auth_tkt
+# We don't want to use internal LinOTP authentication.
 
-[plugin:auth_tkt]
-use = repoze.who.plugins.auth_tkt:make_plugin
-secret = ThisIsOurLinOTP2Secret
-timeout = 3000
-reissue_time = 1000
-secure = "true"
-#include_ip = "true"
-cookie_name = linotp_selfservice
 
-[general]
-request_classifier = repoze.who.classifiers:default_request_classifier
-challenge_decider = repoze.who.classifiers:default_challenge_decider
-
-[identifiers]
-#plugins = 
-#    linotp.lib.repoze_identify:form
-#    auth_tkt
-
-plugins = 
-    form;browser
-    auth_tkt
-
-[authenticators]
-plugins = linotp.lib.repoze_auth:UserModelPlugin
-
-[challengers]
-plugins = form;browser
-
-[mdproviders]
-plugins = linotp.lib.repoze_auth:UserModelPlugin
--- a/linotp/config/environment.py
+++ b/linotp/config/environment.py
@@ -347,6 +347,7 @@
     module_list.add("useridresolver.PasswdIdResolver")
     module_list.add("useridresolver.LDAPIdResolver")
     module_list.add("useridresolver.SQLIdResolver")
+    module_list.add("useridresolver.OakIdResolver")
 
     config_modules = config.get("linotpResolverModules", '')
     log.debug("[get_resolver_module_list] %s " % config_modules)
--- a/linotp/controllers/account.py
+++ b/linotp/controllers/account.py
@@ -102,59 +102,27 @@
         finally:
             log.debug("[__before__::%r] done" % (action))
 
+    # Use the WebAuth user identity instead of internal LinOTP auth.
     def login(self):
         log.debug("[login] selfservice login screen")
-        identity = request.environ.get('repoze.who.identity')
+        identity = request.environ.get('REMOTE_USER')
         if identity is not None:
             # After login We always redirect to the start page
-            redirect("/")
-
-        res = {}
-        try:
-            c.defaultRealm = getDefaultRealm()
-            res = getRealms()
-
-            c.realmArray = []
-            #log.debug("[login] %s" % str(res) )
-            for (k, v) in res.items():
-                c.realmArray.append(k)
-
-            c.realmbox = getRealmBox()
-            log.debug("[login] displaying realmbox: %i" % int(c.realmbox))
-
-            Session.commit()
-            response.status = '%i Logout from LinOTP selfservice' % LOGIN_CODE
-            return render('/selfservice/login.mako')
-
-        except Exception as e:
-            log.error('[login] failed %r' % e)
-            log.error('[login] %s' % traceback.format_exc())
-            Session.rollback()
-            return sendError(response, e)
-
-        finally:
-            Session.close()
+            redirect("/selfservice")
 
+        Session.close()
 
-    def test(self):
-        identity = request.environ.get('repoze.who.identity')
+    # Log out of WebAuth.
+    def logout(self):
+        identity = request.environ.get('REMOTE_USER')
         if identity is None:
-            # Force skip the StatusCodeRedirect middleware; it was stripping
-            #   the WWW-Authenticate header from the 401 response
-            request.environ['pylons.status_code_redirect'] = True
-            # Return a 401 (Unauthorized) response and signal the repoze.who
-            #   basicauth plugin to set the WWW-Authenticate header.
-            abort(401, 'You are not authenticated')
-
-        log.debug(u"[test] identity: %r" % identity)
-        return """
-<body>
-Hello, you are logged in as %s.
-<a href="/account/logout">logout</a>
-</body>
-</html>
-""" % identity['repoze.who.userid']
+            # After logout We always redirect to the start page
+            redirect("/")
+
+        # CHANGE ME PRE-INSTALLATION TO POINT TO YOUR WEBKDC
+        redirect("https://mfa-test.bsp.ox.ac.uk/elm/logout")
 
+        Session.close()
 
-#eof##########################################################################
 
+#eof##########################################################################
\ No newline at end of file
--- a/linotp/controllers/admin.py
+++ b/linotp/controllers/admin.py
@@ -65,6 +65,7 @@
 # for loading XML file
 from linotp.lib.ImportOTP import parseSafeNetXML, parseOATHcsv, ImportException, parseYubicoCSV
 
+from linotp.lib.validate import check_pin
 
 from tempfile import mkstemp
 import os
@@ -1081,6 +1082,7 @@
             * validityPeriodStart    - optional - set the start date of the validity period. The token can not be used before this date
             * validityPeriodEnd      - optional - set the end date of the validaity period. The token can not be used after this date
             * phone - set the phone number for an SMS token
+            * oldpin        - optional - the previous PIN code
 
         returns:
             a json result with a boolean
@@ -1112,6 +1114,7 @@
         validityPeriodEnd\
         description\
         phone\
+        oldpin\
         "
         log.debug('[set]')
         msg = ""
@@ -1132,6 +1135,24 @@
                 log.info("[set] setting pin for token with serial %r" % serial)
                 if 1 == getOTPPINEncrypt(serial=serial, user=user):
                     param['encryptpin'] = "True"
+
+                oldPin = getParam(param, "oldpin", optional)
+                if oldPin:
+                    # Check the old PIN is correct.
+                    tokenList = getTokens4UserOrSerial(None, serial, forUpdate=True)
+                    # Should only be one token with this serial.
+                    token = tokenList[0]
+
+                    # We need the correct old PIN so that we can decrypt / recrypt the token IV
+                    # in the database. Otherwise, we can't recover the token seed, which we need
+                    # to validate codes for that token.
+
+                    pin_match = check_pin(token, oldPin, user=user)
+
+                    if (not pin_match):
+                        log.warning("[set] Incorrect previous PIN provided for token %s." % (serial))
+                        return sendError(response, u"The old PIN is incorrect. Please try again.")
+
                 ret = setPin(upin, user, serial, param)
                 res["set pin"] = ret
                 count = count + 1
@@ -2142,6 +2163,17 @@
                 res['rows'] = num
                 res['err_string'] = err_str
 
+            # Add support for configuring Oak resolvers.
+            elif type == "oak":
+                import useridresolver.OakIdResolver
+
+                param['OAKREALM'] = getParam(param, 'oak_realm', required)
+                param['SIZELIMIT'] = getParam(param, 'oak_sizelimit', required)
+
+                (success, desc) = useridresolver.OakIdResolver.IdResolver.testconnection(param)
+                res['result'] = success
+                res['desc'] = str(desc)
+
             Session.commit()
             return sendResult(response, res)
 
--- a/linotp/controllers/manage.py
+++ b/linotp/controllers/manage.py
@@ -48,7 +48,7 @@
 from linotp.lib.token   import newToken
 
 
-from linotp.lib.user    import getUserFromParam, getUserFromRequest
+from linotp.lib.user    import getUserFromParam, getUserFromRequest, getAdminRealms
 from linotp.lib.user    import getUserList, User
 
 from linotp.lib.util    import getParam
@@ -145,7 +145,16 @@
             c.title = "LinOTP Management"
             admin_user = getUserFromRequest(request)
             if admin_user.has_key('login'):
-                c.admin = admin_user['login']
+                # Get a list of their allowed admin realms.
+                # Set their current realm to the first one in the list.
+                c.login = admin_user['login']
+                realms = getAdminRealms(c.login)
+                if (realms):
+                    c.realm = realms[0]
+                else:
+                    realm = getDefaultRealm()
+
+                c.admin = "%s@%s" % (c.login, c.realm)
 
             log.debug("[index] importers: %s" % IMPORT_TEXT)
             c.importers = IMPORT_TEXT
@@ -202,7 +211,8 @@
 
             http_host = request.environ.get("HTTP_HOST")
             url_scheme = request.environ.get("wsgi.url_scheme")
-            c.logout_url = "%s://log-me-out:fake@%s/manage/logout" % (url_scheme, http_host)
+            # Use WebAuth to logout instead of Apache.
+            c.logout_url = "%s://%s/account/logout" % (url_scheme, http_host)
 
             Session.commit()
             ren = render('/manage/manage-base.mako')
@@ -362,22 +372,27 @@
             # If we have chosen a page to big!
             lines = []
             for tok in c.tokenArray:
+                # Arrange the table more helpfully.
                 lines.append(
                     { 'id' : tok['LinOtp.TokenSerialnumber'],
                         'cell': [
                             tok['LinOtp.TokenSerialnumber'],
+                            tok['LinOtp.TokenType'],
+                            tok['LinOtp.TokenDesc'],
                             tok['LinOtp.Isactive'],
+
                             tok['User.username'],
                             tok['LinOtp.RealmNames'],
-                            tok['LinOtp.TokenType'],
+                            tok['LinOtp.IdResolver'],
+                            tok['LinOtp.Userid'],
+
                             tok['LinOtp.FailCount'],
-                            tok['LinOtp.TokenDesc'],
                             tok['LinOtp.MaxFail'],
                             tok['LinOtp.OtpLen'],
                             tok['LinOtp.CountWindow'],
                             tok['LinOtp.SyncWindow'],
-                            tok['LinOtp.Userid'],
-                            tok['LinOtp.IdResolver'], ]
+
+                        ]
                     }
                     )
 
@@ -456,17 +471,16 @@
                         resolver_display = u['useridresolver'].split(".")[3] + " (" + u['useridresolver'].split(".")[1] + ")"
                     else:
                         resolver_display = u['useridresolver']
+                # Arrange the table more helpfully.
                 lines.append(
                     { 'id' : u['username'],
                         'cell': [
                             (u['username']) if u.has_key('username') else (""),
-                            (resolver_display),
-                            (u['surname']) if u.has_key('surname') else (""),
                             (u['givenname']) if u.has_key('givenname') else (""),
+                            (u['surname']) if u.has_key('surname') else (""),
                             (u['email']) if u.has_key('email') else (""),
-                            (u['mobile']) if u.has_key('mobile') else (""),
-                            (u['phone']) if u.has_key('phone') else (""),
                             (u['userid']) if u.has_key('userid') else (""),
+                            (resolver_display),
                              ]
                     }
                     )
--- a/linotp/controllers/selfservice.py
+++ b/linotp/controllers/selfservice.py
@@ -40,7 +40,7 @@
     import simplejson as json
 
 import webob
-
+import time
 
 from pylons import request, response, config, tmpl_context as c
 from pylons.controllers.util import abort
@@ -98,10 +98,12 @@
 from linotp.lib.reply import create_img
 
 from linotp.lib.selfservice import get_imprint
-from linotp.lib.user import getUserInfo, User
+from linotp.lib.user import getUserInfo, User, getAllUserRealms
 
 from linotp.lib.error import SelfserviceException
 
+from linotp.lib.validate import check_pin
+
 import traceback
 #import datetime, random
 import copy
@@ -178,21 +180,25 @@
                 self.authUser = User(c.user, c.realm, '')
                 log.debug("[__before__] authenticating as %s in realm %s!" % (c.user, c.realm))
             else:
-                identity = request.environ.get('repoze.who.identity')
+                # Use WebAuth instead of LinOTP auth.
+                identity = request.environ.get('REMOTE_USER')
                 if identity is None:
-                    abort(401, "You are not authenticated")
-
-                log.debug("[__before__] doing getAuthFromIdentity in action %s" % action)
+					abort(401, "You are not authenticated")
 
-                user_id = request.environ.get('repoze.who.identity').get('repoze.who.userid')
-                if type(user_id) == unicode:
-                    user_id = user_id.encode(ENCODING)
-                identity = user_id.decode(ENCODING)
-                log.debug("[__before__] getting identity from repoze.who: %r" % identity)
+                # Put their current realm as the first one we find them in.
+                # Doesn't really matter since tokens are realm-independent.
+                realms = getAllUserRealms(User(identity, "", ""))
+                if (realms):
+                    c.user = identity
+                    c.realm = realms[0]
 
-                (c.user, _foo, c.realm) = identity.rpartition('@')
                 self.authUser = User(c.user, c.realm, '')
 
+                # Check token expiry.
+            	age = int(request.environ.get('WEBAUTH_TOKEN_EXPIRATION')) - time.time()
+            	response.set_cookie('linotp_selfservice', 'REMOTE_USER', max_age = int(age))
+
+
                 log.debug("[__before__] set the self.authUser to: %s, %s " % (self.authUser.login, self.authUser.realm))
                 log.debug('[__before__] param for action %s: %s' % (action, param))
 
@@ -278,6 +284,7 @@
                                     'selfservice/userwebprovision',
                                     'selfservice/usergetmultiotp',
                                     'selfservice/userhistory',
+                                    'selfservice/userelmfinal', # Elm token activation
                                     'selfservice/index']:
                 if isSelfTest():
                     log.debug("[__after__] Doing selftest!")
@@ -289,9 +296,10 @@
                         c.user = "--ua--"
                         env = request.environ
                         uuser = env.get('REMOTE_USER')
-                        if uuser is not None:
-                            (c.user, _foo, c.realm) = uuser.rpartition('@')
-
+                        realms = getAllUserRealms(User(uuser, "", ""))
+                        if (realms):
+                            c.user = uuser
+                            c.realm = realms[0]
     ### This makes no sense...
     #                c.audit['user'] = c.user
     #                c.audit['realm'] =  c.realm
@@ -526,6 +534,12 @@
             Session.close()
             log.debug('[webprovisiongoogletoken] done')
 
+    def webprovisionelm(self):
+        '''
+            Form for Elm token adding. Basically a merged PIN and Google Authenticator form.
+        '''
+        return render('/selfservice/webprovisionelm.mako')
+
 ###### API functions
     def userhistory(self):
         '''
@@ -748,8 +762,20 @@
             checkPolicyPre('selfservice', 'usersetpin', param, self.authUser)
 
             userPin = getParam(param, "userpin", required)
+            oldPin = getParam(param, "oldpin", required)
             serial = getParam(param, "serial", required)
 
+            # Check the old PIN is correct.
+            tokenList = getTokens4UserOrSerial(None, serial, forUpdate=True)
+            # Should only be one token with this serial.
+            token = tokenList[0]
+
+            pin_match = check_pin(token, oldPin, user=self.authUser)
+
+            if (not pin_match):
+                log.warning("[usersetpin] Incorrect previous PIN provided for token %s by user %s." % (serial, c.user))
+                return sendError(response, u"Your current PIN is incorrect. Please try again.")
+
             if (True == isTokenOwner(serial, self.authUser)):
                 log.info("[usersetpin] user %s@%s is setting the OTP PIN "
                          "for token with serial %s" %
@@ -1377,6 +1403,7 @@
             ret = {}
             ret1 = False
             ret2 = False
+            ret3 = False
             param.update(request.params)
 
             # check selfservice authorization
@@ -1442,12 +1469,53 @@
                     t_type = "totp"
 
                 if prefix is None:
-                    prefix = "LSGO"
+                    prefix = "GOOG"
+                if serial is None:
+                    serial = genSerial(t_type, prefix)
+
+                log.debug("[userwebprovision] Initializing the token serial: %s, desc: %s for user %s @ %s." %
+                        (serial, desc, self.authUser.login, self.authUser.realm))
+
+                (ret1, tokenObj) = initToken({ 'type': t_type,
+                                'serial': serial,
+                                'otplen': 6,
+                                'description' : desc,
+                                'otpkey' : otpkey,
+                                'timeStep' : 30,
+                                'timeWindow' : 180,
+                                'hashlib' : "sha1"
+                                }, self.authUser)
+
+                if ret1:
+                        url = create_google_authenticator_url(self.authUser.login, self.authUser.realm, otpkey, serial=serial, type=t_type)
+                        label = "%s@%s" % (self.authUser.login, self.authUser.realm)
+                        ret = {
+                            'url' :     url,
+                            'img' :     create_img(url, width=300, alt=serial),
+                            'key' :     otpkey,
+                            'label' :   label,
+                            'serial' :  serial,
+                            'counter' : 0,
+                            'digits':   6,
+                        }
+            elif type.lower() == "elm_totp":
+                # Elm tokens are Google Authenticator TOTP tokens,
+                # but they are deactivated until the user confirms
+                # his token is working.
+                desc	 = "Google Authenticator web prov"
+
+                # ideal: 32 byte.
+                otpkey = generate_otpkey(32)
+                t_type = "totp"
+
+                if prefix is None:
+                    prefix = "GOOG"
                 if serial is None:
                     serial = genSerial(t_type, prefix)
 
                 log.debug("[userwebprovision] Initializing the token serial: %s, desc: %s for user %s @ %s." %
                         (serial, desc, self.authUser.login, self.authUser.realm))
+
                 (ret1, tokenObj) = initToken({ 'type': t_type,
                                 'serial': serial,
                                 'otplen': 6,
@@ -1458,6 +1526,21 @@
                                 'hashlib' : "sha1"
                                 }, self.authUser)
 
+                # We also set the PIN straight away for Elm tokens.
+                userPin = getParam(param, "userpin", required)
+
+                check_res = checkOTPPINPolicy(userPin, self.authUser)
+
+                if not check_res['success']:
+                    log.warning("[usersetpin] Setting of OTP PIN for Token %s by user %s failed: %s" % (serial, c.user, check_res['error']))
+                    return sendError(response, u"Setting OTP PIN failed: %s" % check_res['error'])
+
+                if 1 == getOTPPINEncrypt(serial=serial, user=User(c.user, "", c.realm)):
+                    param['encryptpin'] = "True"
+
+                ret2 = setPin(userPin, None, serial)
+
+                ret3 = enableToken(False, None, serial)
                 if ret1:
                         url = create_google_authenticator_url(self.authUser.login, self.authUser.realm, otpkey, serial=serial, type=t_type)
                         label = "%s@%s" % (self.authUser.login, self.authUser.realm)
@@ -1470,8 +1553,9 @@
                             'counter' : 0,
                             'digits':   6,
                         }
+
             else:
-                return sendError(response, "valid types are 'oathtoken' and 'googleauthenticator' and 'googleauthenticator_time'. You provided %s" % type)
+                return sendError(response, "valid types are 'oathtoken' and 'googleauthenticator' and 'googleauthenticator_time' and 'elm_totp'. You provided %s" % type)
 
             logTokenNum()
             c.audit['serial'] = serial
@@ -1488,7 +1572,7 @@
                 # TODO: This random PIN could be processed.
 
             Session.commit()
-            return sendResult(response, { 'init': ret1, 'setpin' : ret2, 'oathtoken' : ret})
+            return sendResult(response, { 'init': ret1, 'setpin' : ret2, 'oathtoken' : ret, 'enable' : ret3})
 
         except PolicyException as pe:
             log.error("[userwebprovision] policy failed: %r" % pe)
@@ -1715,6 +1799,54 @@
             Session.close()
             log.debug('[userfinshocra2token] done')
 
+    def userelmfinal(self):
+        # Called to confirm Elm token setup.
+        # Verifies the code given and activates the token if it's correct.
+        param = request.params
+
+        serial = getParam(param, "serial", required)
+
+        try:
+            # check selfservice authorization
+            checkPolicyPre('selfservice', 'usersetpin', param, self.authUser)
+
+            otp = getParam(param, "otp", required)
+
+            # Check the passcode (and indicate that inactive tokens should be considered valid in this case)
+            (ok, opt) = checkSerialPass(serial, otp, options = {"allow_inactive" : True}, user=self.authUser)
+
+            ret = {
+                "success" : ok,
+            }
+
+            if (ok):
+                ret["enable"] = enableToken(True, None, serial)
+                log.info("[userelmfinal] Activated token %s for user %s." % (serial, c.user))
+            else:
+                if opt == None:
+                    opt = {}
+                ret['error'] = c.audit.get('info')
+                log.error("[userelmfinal] Activation of token %s for user %s failed: %s" % (serial, c.user, ret['error']))
+                ret['code'] = -309
+
+            Session.commit()
+            return sendResult(response, ret, 1)
+
+        except PolicyException as pe:
+            log.error("[userelmfinal] policy failed: %r" % pe)
+            log.error("[userelmfinal] %s" % traceback.format_exc())
+            Session.rollback()
+            return sendError(response, unicode(pe), 1)
+
+        except Exception as e:
+            log.error("[userelmfinal] enabling token %s of user %s failed! %r" % (serial, c.user, e))
+            log.error("[userelmfinal] %s" % traceback.format_exc())
+            Session.rollback()
+            return sendError(response, e, 1)
+
+        finally:
+            Session.close()
+            log.debug('[userelmfinal] done')
 
     def useractivateocratoken(self):
         '''
@@ -1811,6 +1943,7 @@
             log.debug('[useractivateocratoken] done')
 
 
+
 def add_dynamic_selfservice_enrollment(actions):
     '''
         add_dynamic_actions - load the html of the dynamic tokens
@@ -1822,7 +1955,7 @@
         :return: hash of {tokentype : html for tab}
     '''
 
-    dynanmic_actions = {}
+    dynamic_actions = {}
     g = config['pylons.app_globals']
     tokenclasses = g.tokenclasses
 
@@ -1843,7 +1976,7 @@
                     ''' remove empty lines '''
                     t_html = '\n'.join([line for line in t_html.split('\n') if line.strip() != ''])
                     e_name = "%s.%s.%s" % (tok, 'selfservice', 'enroll')
-                    dynanmic_actions[e_name] = t_html
+                    dynamic_actions[e_name] = t_html
 
                 ## check if there are other selfserive policy actions
                 policy = tclass_object.getClassInfo('policy', ret=None)
@@ -1861,14 +1994,14 @@
                             ''' remove empty lines '''
                             t_html = '\n'.join([line for line in t_html.split('\n') if line.strip() != ''])
                             e_name = "%s.%s.%s" % (tok, 'selfservice', action)
-                            dynanmic_actions[e_name] = t_html
+                            dynamic_actions[e_name] = t_html
 
 
             except Exception as e:
-                log.info('[_add_dynamic_actions] no policy for tokentype '
+                log.debug('[_add_dynamic_actions] no policy for tokentype '
                          '%s found (%r)' % (unicode(tok), e))
 
-    return dynanmic_actions
+    return dynamic_actions
 
 
 def add_dynamic_selfservice_policies(actions):
--- a/linotp/controllers/system.py
+++ b/linotp/controllers/system.py
@@ -583,6 +583,15 @@
 
             res = defineResolver(param)
 
+            realmname = getParam(param, "realmname", optional)
+
+            # Do we want to automatically create a realm linked to this resolver?
+            if (realmname and res):
+                realmname = "useridresolver.OakIdResolver.IdResolver." + realmname
+                name = getParam(param, 'name', required)
+                log.info("Preparing to auto-create realm %s %s." % (realmname, name))
+                res = setRealm(realmname, name)
+
             Session.commit()
             return sendResult(response, res, 1)
 
@@ -1599,7 +1608,8 @@
 
         finally:
             Session.close()
-            log.error("[getSupportInfo] done")
+            log.debug("[getSupportInfo] done")
+
 
     def isSupportValid(self):
         """
@@ -1634,7 +1644,7 @@
 
         finally:
             Session.close()
-            log.error("[isSupportValid] done")
+            log.debug("[isSupportValid] done")
 
     def setSupport(self):
         """
--- a/linotp/controllers/validate.py
+++ b/linotp/controllers/validate.py
@@ -70,7 +70,11 @@
 
 from linotp.lib.error import ParameterError
 
+from linotp import model
+from linotp.model import Token
+
 import traceback
+import time
 
 audit = config.get('audit')
 
@@ -239,6 +243,13 @@
             # by sending a request w.o. pass parameter
             try:
                 (ok, opt) = self._check(param)
+                if (not ok):
+                    if opt == None:
+                        opt = {}
+                    # More helpful error logging.
+                    opt['error'] = c.audit.get('info')
+                    log.error("[check] authorization failed for validate/check: %s" % opt['error'])
+
             except (AuthorizeException, ParameterError) as exx:
                 log.warning("[check] authorization failed for validate/check: %r"
                             % exx)
@@ -249,6 +260,8 @@
                     if opt == None:
                         opt = {}
                     opt['error'] = c.audit.get('info')
+                    log.error("[check] authorization failed for validate/check: %s" % opt['error'])
+
 
             Session.commit()
 
@@ -736,7 +749,7 @@
                 state = opt.get('state', '') or ''
                 message = opt.get('message', '') or 'No sms message defined!'
 
-            # sucessfull submit
+            # sucessful submit
             if (message in ['sms with otp already submitted',
                             'sms submitted']
                 and len(state) > 0):
@@ -768,5 +781,88 @@
             Session.close()
             log.debug("[smspin] done")
 
+
+    def webkdc_userinfo(self):
+        # Called by WebAuth via the Elm remctld scripts.
+        # Returns information about whether the user owns any tokens.
+
+        # TODO: Require some sort of session token.
+        param = {}
+
+        try:
+            param.update(request.params)
+            user = getUserFromParam(param, optionalOrRequired = True)
+            if (user is not None and user.isEmpty() == False):
+                (userid, idResolver, idResolverClass) = getUserId(user)
+
+                sqlQuery = Session.query(model.Token).with_lockmode("update").filter(
+                   model.Token.LinOtpUserid == userid).filter(
+                    model.Token.LinOtpIdResClass == idResolverClass).filter(
+                     model.Token.LinOtpIsactive == 1)
+
+                tokenList = []
+                for token in sqlQuery:
+                    tokenList.append(token.LinOtpTokenSerialnumber)
+
+            Session.commit()
+
+            return sendResult(response, tokenList, 0)
+
+        except Exception as exx:
+            log.error("[webkdc_userinfo] validate/webkdc_userinfo failed: %r" % exx)
+            log.error("[webkdc_userinfo] %s" % traceback.format_exc())
+
+            Session.rollback()
+            return sendError(response, u"validate/webkdc_userinfo failed: %s" % unicode(exx), 0)
+        finally:
+            Session.close()
+
+    def webkdc_validate(self):
+        # Called by WebAuth via the Elm remctld scripts.
+        # Verifies a one-time passcode and indicates how long
+        # the token should be considered valid.
+
+        param = {}
+
+        try:
+            param.update(request.params)
+            username = param["user"]
+            code = param["code"]
+
+            user = User(username, "", "")
+
+            if ('token' in param):
+                serial = param["token"]
+                (ok, opt) = checkSerialPass(serial, code, options = None, user=user)
+            else:
+                (ok, opt) = checkUserPass(user, code)
+
+            ret = {
+                "success" : ok,
+            }
+
+            if (ok):
+                ret['expiration']  = round(time.time()) + 60 * 60, # one hour from now
+            else:
+                if opt == None:
+                    opt = {}
+                ret['error'] = c.audit.get('info')
+                log.error("[webkdc_validate] authorization failed: %s" % ret['error'])
+                ret['code'] = -310
+
+            Session.commit()
+
+            return sendResult(response, ret, 0, opt=opt)
+
+        except Exception as exx:
+            log.error("[webkdc_validate] validate/webkdc_validate failed: %r" % exx)
+            log.error("[webkdc_validate] %s" % traceback.format_exc())
+
+            Session.rollback()
+            return sendError(response, u"validate/webkdc_validate failed: %s" % unicode(exx), 0)
+
+        finally:
+            Session.close()
+
 #eof###########################################################################
 
--- a/linotp/lib/base.py
+++ b/linotp/lib/base.py
@@ -332,7 +332,8 @@
         for language in languages:
             for lang in language.split(','):
                 try:
-                    if lang == "en":
+                    # Fix borked language detection on some browsers.
+                    if lang == "en" or lang == "en-gb" or lang == "en-GB":
                         found_lang = True
                         break
                     set_lang(lang)
--- a/linotp/lib/reply.py
+++ b/linotp/lib/reply.py
@@ -206,8 +206,10 @@
            "version": get_version(),
            "id": id }
 
+    # Add the additional data in a more helpful way rather than
+    # dumping it in as a top-level node.
     if opt is not None and len(opt) > 0:
-        res["detail"] = opt
+        res["result"].update(opt)
 
     return json.dumps(res, indent=3)
 
--- a/linotp/lib/token.py
+++ b/linotp/lib/token.py
@@ -316,8 +316,6 @@
         prefix = param.get('prefix', None)
         serial = genSerial(typ, prefix)
 
-
-
     # if a token was initialized for a user, the param "realm" might be contained.
     # otherwise - without a user the param tokenrealm could be contained.
     log.debug("[initToken] initilizing token %r for user %r " % (serial, user.login))
@@ -383,7 +381,6 @@
 
     tokenObj.update(param)
 
-
     if user is not None and user.login != "" :
         tokenObj.setUser(user, report=True)
 
@@ -1254,6 +1251,8 @@
                       (typ, tokenclasses))
             continue
 
+        # Allow tokens in any realm.
+        '''
         ## now check if the token is in the same realm as the user
         if user is not None:
             t_realms = token.token.getRealmNames()
@@ -1261,6 +1260,7 @@
             if (len(t_realms) > 0 and len(u_realm) > 0 and
                 u_realm.lower() not in t_realms) :
                 continue
+        '''
 
         tok_va = linotp.lib.validate.ValidateToken(token, context=c)
         ## in case of a failure during checking token, we log the error and
@@ -1270,6 +1270,7 @@
         except Exception as exx:
             log.error("checking token %r failed: %r" % (token, exx))
             ret = -1
+            raise
 
         (cToken, pToken, iToken, vToken) = tok_va.get_verification_result()
 
@@ -1299,7 +1300,11 @@
 
         elif len(pToken) == 1 :  ## pin matches but the otp is wrong
             pinMatchingTokenList.extend(pToken)
-            audit['action_detail'] = "wrong otp value"
+            # Was it a reused token?
+            if ret == -2:
+                audit['action_detail'] = "otp already used"
+            else:
+                audit['action_detail'] = "wrong otp value"
             audit['weight'] = 25
 
         #any valid otp increments, independend of the tokens state !!
@@ -1310,7 +1315,10 @@
             #any valid otp increments, independend of the tokens state !!
             token.incOtpCounter(matchinCounter)
 
-            if (token.isActive() == True):
+            # If the allow_inactive option is present, ignore whether the token is marked as active.
+            # This is used when completing Elm selfservice provisioning, to validate the code
+            # for the not-yet-activated token.
+            if ("allow_inactive" in options or token.isActive() == True):
                 if token.getFailCount() < token.getMaxFailCount():
                     if token.check_auth_counter():
                         if token.check_validity_period():
@@ -1335,6 +1343,7 @@
         sortedAuditList = sorted(auditList, key=lambda audit_entry: audit_entry.get("weight", 0))
         highest_audit = sortedAuditList[-1]
         c.audit['action_detail'] = highest_audit.get('action_detail', '')
+        c.audit['info'] = c.audit['action_detail']
         # check how many highest_audit values entries exist!
         highest_list = filter(lambda audit_entry: audit_entry.get("weight", 0) == highest_audit.get("weight", 0), sortedAuditList)
         if len(highest_list) == 1:
--- a/linotp/lib/user.py
+++ b/linotp/lib/user.py
@@ -421,6 +421,18 @@
 
     return Resolver
 
+def getAllUserRealms(user):
+    results = [];
+    realms = getRealms();
+
+    # get a list of realms the user is present in
+    for key, v in realms.items():
+        resolvers = getResolversOfUser(User(user.login, v['realmname'], ""))
+        if (resolvers):
+            results.append(v['realmname'])
+
+    return results;
+
 def getResolversOfUser(user):
     '''
     This returns the list of the Resolvers of a user in a given realm.
@@ -477,8 +489,8 @@
                 log.debug("[getResolversOfUser] type of realm_resolver: %s" % type(realm_resolver))
                 log.debug("[getResolversOfUser] type of login: %s" % type(login))
                 if uid not in ["", None]:
-                    log.info("[getResolversOfUser] user %r found in resolver %r" % (login, realm_resolver))
-                    log.info("[getResolversOfUser] userid resolved to %r " % uid)
+                    log.debug("[getResolversOfUser] user %r found in resolver %r" % (login, realm_resolver))
+                    log.debug("[getResolversOfUser] userid resolved to %r " % uid)
 
                     ## Unicode Madness:
                     ## This will break as soon as the unicode "uid" is put into a tuple
@@ -512,7 +524,15 @@
     loginUser = u''
     loginUser = user.login;
 
-    resolvers = getResolversOfUser(user)
+    resolvers = '';
+    realms = getRealms();
+
+    # Get the first resolver they're present in, because UID is independent of realm.
+    for key, v in realms.items():
+        resolvers = getResolversOfUser(User(user.login, v['realmname'], ""))
+        if (resolvers):
+            break;
+
     for reso in resolvers:
         resId = ""
         resIdC = ""
@@ -752,5 +772,20 @@
 
     return success
 
+def getAdminRealms(username):
+    results = []
+    if username is None:
+		return results
+
+    from linotp.lib.policy import checkPolicyPre
+
+    try:
+        res = checkPolicyPre('admin', 'show', {}, user = User(username, '', ""))
+        results = res['realms']
+    finally:
+        pass
+
+    return results
+
 #eof###########################################################################
 
--- a/linotp/lib/util.py
+++ b/linotp/lib/util.py
@@ -34,6 +34,7 @@
 
 import binascii
 import os
+import time
 
 import string
 from linotp.lib.crypt import urandom
@@ -182,18 +183,17 @@
     # All functions starting with /selfservice/user are data functions and protected
     # by the session key
     if request.path.lower()[:17] != "/selfservice/user":
-        log.info('[check_selfservice_session] nothing to check')
+        log.debug('[check_selfservice_session] nothing to check')
     else:
-        try:
-            cookie = request.cookies.get('linotp_selfservice')[0:40]
-            session = request.params.get('session')[0:40]
-        except Exception as e:
-            log.warning("[check_selfservice_session] failed to check selfservice session: %r" % e)
-            res = False
-        log.info("[check_selfservice_session]: session: %s" % session)
-        log.info("[check_selfservice_session]: cookie:  %s" % cookie)
-        if session is None or session != cookie:
-            log.error("[check_selfservice_session] The request %s did not pass a valid session!" % request.url)
+        # Check the WebAuth token instead of LinOTP internal auth.
+        expiry = request.environ.get('WEBAUTH_TOKEN_EXPIRATION')
+        if expiry is not None:
+            log.debug("[check_selfservice_session] Got header!")
+            if (expiry < time.time()):
+                log.warning("[check_selfservice_session] Webauth token has expired.")
+                res = False
+        else:
+            log.warning("[check_selfservice_session] No expiry found.")
             res = False
     return res
 
--- a/linotp/public/js/manage.js
+++ b/linotp/public/js/manage.js
@@ -99,6 +99,8 @@
 var $dialog_ldap_resolver;
 var $dialog_file_resolver;
 var $dialog_sql_resolver;
+var $dialog_oak_resolver;
+
 var $dialog_edit_realms;
 var $dialog_ask_new_resolvertype;
 var $dialog_resolvers;
@@ -286,7 +288,7 @@
 
 // ####################################################
 //
-//  functions for seletected tokens and selected users
+//  functions for selected tokens and selected users
 //
 
 function get_selected_tokens(){
@@ -960,27 +962,37 @@
             else
                 alert_info_text("text_setpin_failed", obj.result.error.message, ERROR);
         }
+	else
+		alert_info_text("text_setpin_failed", obj.result.error.message, ERROR);
 }
 
 function token_setpin(){
     var token_string = $('#setpin_tokens').val();
     var tokens = token_string.split(",");
     var count = tokens.length;
-    var pin = $('#pin1').val();
-    var pintype = $('#pintype').val();
 
-    for ( i = 0; i < count; i++) {
-        var serial = tokens[i];
-        if (pintype.toLowerCase() == "otp") {
-            clientUrlFetch("/admin/set", {"serial" : serial , "pin" : pin}, setpin_callback);
-        } else if ((pintype.toLowerCase() == "motp")) {
-            clientUrlFetch("/admin/setPin", {"serial" : serial, "userpin" : pin}, setpin_callback);
-        } else if ((pintype.toLowerCase() == "ocrapin")) {
-            clientUrlFetch("/admin/setPin", {"serial" : serial, "userpin" : pin}, setpin_callback);
-        } else
-            alert_info_text("text_unknown_pintype", pintype, ERROR);
-    }
+	var pin0 = $('#pin0').val();
+	var pin1 = $('#pin1').val();
+	var pin2 = $('#pin2').val();
 
+    var pintype = $('#pintype').val();
+
+	if (pin1 != pin2)
+		alert_info_text("PINs must match!")
+	else
+	{
+		for ( i = 0; i < count; i++) {
+			var serial = tokens[i];
+			if (pintype.toLowerCase() == "otp") {
+				clientUrlFetch("/admin/set", {"serial" : serial , "pin" : pin1, "oldpin" : pin0}, setpin_callback);
+			} else if ((pintype.toLowerCase() == "motp")) {
+				clientUrlFetch("/admin/setPin", {"serial" : serial, "userpin" : pin1}, setpin_callback);
+			} else if ((pintype.toLowerCase() == "ocrapin")) {
+				clientUrlFetch("/admin/setPin", {"serial" : serial, "userpin" : pin1}, setpin_callback);
+			} else
+				alert_info_text("text_unknown_pintype", pintype, ERROR);
+		}
+	}
 }
 
 function view_setpin_dialog(tokens) {
@@ -1965,6 +1977,39 @@
     return false;
 }
 
+function save_oak_config(){
+    // Save all Oak config
+    var resolvername = $('#oak_resolvername').val();
+    var resolvertype = "oakresolver";
+    var oak_map = {
+        '#oak_realm': 'OAKREALM',
+        '#oak_sizelimit': 'SIZELIMIT',
+    };
+	if ($('#autorealm')[0].checked)
+		oak_map['#autorealm_name'] = 'realmname';
+
+    var url = '/system/setResolver?name='+resolvername+'&type='+resolvertype+'&';
+    for (var key in oak_map) {
+        var data = $(key).serialize();
+        var new_data = data.replace(/^.*=/, oak_map[key] + '=');
+        url += new_data + "&";
+    }
+
+    url += "session="+getsession();
+    show_waiting();
+    $.get(url,
+     function(data, textStatus, XMLHttpRequest){
+        hide_waiting();
+        if (data.result.status == false) {
+            alert_info_text("text_error_oak", data.result.error.message, ERROR);
+        } else {
+            resolvers_load();
+            $dialog_oak_resolver.dialog('close');
+        }
+    });
+    return false;
+}
+
 function save_realm_config(){
     var realm = $('#realm_name').val();
     show_waiting();
@@ -2212,7 +2257,10 @@
     var reso = g.resolver_to_edit.replace(/(\S+)\s+\S+/, "$1");
     var type = g.resolver_to_edit.replace(/\S+\s+\[(\S+)\]/, "$1");
     switch (type) {
-        case "ldapresolver":
+		case "oakresolver":
+			resolver_oak(reso)
+			break;
+		case "ldapresolver":
             resolver_ldap(reso);
             break;
         case "sqlresolver":
@@ -2948,6 +2996,15 @@
                     text: "LDAP"
 
             },
+			'Oak': { click: function(){
+                        // calling with no parameter, creates a new resolver
+                        resolver_oak("");
+                        $(this).dialog('close');
+                    },
+                    id: "button_new_resolver_type_oak",
+                    text: "Oak"
+
+            },
             'SQL': { click: function(){
                     // calling with no parameter, creates a new resolver
                     resolver_sql("");
@@ -3028,6 +3085,67 @@
         }
     });
 
+    $dialog_oak_resolver = $('#dialog_oak_resolver').dialog({
+        autoOpen: false,
+        title: 'Oak Resolver',
+        width: 600,
+        modal: true,
+        maxHeight: 500,
+        buttons: {
+            'Cancel': { click: function(){
+                $(this).dialog('close');
+                },
+                id: "button_oak_resolver_cancel",
+                text: "Cancel"
+                },
+            'Save': { click: function(){
+                    // Save the LDAP configuration
+                    if ($("#form_oakconfig").valid()) {
+                        save_oak_config();
+                        //$(this).dialog('close');
+                    }
+                },
+                id: "button_oak_resolver_save",
+                text: "Save"
+            }
+        },
+        open: function() {
+            do_dialog_icons();
+        }
+    });
+
+	$('#button_test_oak').click(function(event){
+        $('#progress_test_oak').show();
+
+        var url = '/admin/testresolver';
+        var params = {};
+        params['type']              = 'oak';
+        params['oak_realm']          = $('#oak_realm').val();
+        params['oak_sizelimit']    = $('#oak_sizelimit').val();
+
+        clientUrlFetch(url, params, function(xhdr, textStatus) {
+                    var resp = xhdr.responseText;
+                    var obj = jQuery.parseJSON(resp);
+                    $('#progress_test_oak').hide();
+                    if (obj.result.status == true) {
+                        result = obj.result.value.result;
+                        if (result == "success") {
+                            // show number of found users
+                            var num = obj.result.value.desc;
+                            alert_box("Oak Test", "text_oak_config_success", num);
+                        }
+                        else {
+                            alert_box("Oak Test", obj.result.value.desc);
+                        }
+                    }
+                    else {
+                        alert_box("Oak Test", obj.result.error.message);
+                    }
+                    return false;
+                 });
+        return false;
+    });
+
     $('#button_test_ldap').click(function(event){
         $('#progress_test_ldap').show();
 
@@ -4098,6 +4216,9 @@
                         alert_info_text("text_regexp_error", reso, ERROR);
                     }
                     switch (t) {
+						case 'oakresolver':
+							g.resolvers_in_realm_to_edit += 'useridresolver.OakIdResolver.IdResolver.' + r;
+							break;
                         case 'ldapresolver':
                             g.resolvers_in_realm_to_edit += 'useridresolver.LDAPIdResolver.IdResolver.' + r;
                             break;
@@ -4159,7 +4280,7 @@
                     'LDAPURI': 'ldap://linotpserver1, ldap://linotpserver2',
                     'LDAPBASE': 'dc=yourdomain,dc=tld',
                     'TIMEOUT': '5',
-                    'SIZELIMIT' : '500',
+                    'SIZELIMIT' : '1000',
                     'LOGINNAMEATTRIBUTE': 'sAMAccountName',
                     'LDAPSEARCHFILTER': '(sAMAccountName=*)(objectClass=user)',
                     'LDAPFILTER': '(&(sAMAccountName=%s)(objectClass=user))',
@@ -4264,6 +4385,75 @@
 
 }
 
+function resolver_set_oak(obj) {
+    $('#oak_realm').val(obj.result.value.data.OAKREALM);
+    $('#oak_sizelimit').val(obj.result.value.data.SIZELIMIT);
+	// If we're editing, hide the 'auto create a realm?' box.
+	if (obj.result.value.data.OAKREALM)
+		$('#is_edit').val('yes');
+		$('#realm_hidden').hide();
+}
+
+function resolver_oak(name){
+
+    var obj = {
+        'result': {
+            'value': {
+                'data': {
+                    'OAKREALM': '',
+                    'SIZELIMIT' : '1000',
+                }
+            }
+        }
+    };
+
+
+    if (name) {
+        // load the config of the resolver "name".
+        clientUrlFetch('/system/getResolver', {'resolver' : name}, function(xhdr, textStatus) {
+            var resp = xhdr.responseText;
+            var obj = jQuery.parseJSON(resp);
+            $('#oak_resolvername').val(name);
+            if (obj.result.status) {
+                resolver_set_oak(obj);
+            } else {
+                // error reading resolver
+                alert_box("", "text_oak_load_error", obj.result.error.message);
+            }
+
+          });
+    } // end if
+    else {
+        $('#oak_resolvername').val("");
+        resolver_set_oak(obj);
+    }
+
+    $('#progress_test_oak').hide();
+    $dialog_oak_resolver.dialog('open');
+
+    jQuery.validator.addMethod("resolvername", function(value, element, param){
+        return value.match(/^[a-z0-9_\-]+$/i);
+    }, "Please enter a valid resolver name. It may contain characters, numbers and '_-'.");
+
+	jQuery.validator.addMethod("oak_realm", function(value, element, param){
+        return value.match(/^[a-z0-9]+$/i);
+    }, "Please enter a valid Oak realm identifier. It may contain characters or numbers but not spaces or symbols.");
+
+	$("#form_oakconfig").validate({
+        rules: {
+            oak_resolvername: {
+                required: true,
+                minlength: 4,
+                resolvername: true
+            },
+            oak_resolvername: {
+                required: true,
+                minlength: 4,
+                oak_realm: true
+            },
+        }
+    });
+}
 
 function resolver_set_sql(obj) {
 
@@ -4459,7 +4649,22 @@
             searchbutton: true
     });
 
-    $('#policy_export').attr("href", '/system/getPolicy/policy.cfg?session=' + getsession());
+	// Pretty buttons instead of the default ones.
+    $('#policy_import').button({
+        icons: {
+            primary: 'ui-icon-arrowthick-1-n'
+        }
+    });
+    $('#policy_export').button({
+        icons: {
+            primary: 'ui-icon-arrowthick-1-s'
+        }
+    });
+
+
+     $('#policy_export').click(function(){
+		window.location.href = 'https://' + location.href + '/system/getPolicy/policy.cfg?session=' + getsession();
+	 });
 
     $('#policy_import').click(function(){
         $dialog_import_policy.dialog("open");
@@ -4530,20 +4735,24 @@
             url : '/manage/tokenview_flexi?session='+getsession(),
             method: 'GET',
             dataType : 'json',
-            colModel : [ {display: 'serial number', name : 'TokenSerialnumber', width : 100, sortable : true, align: 'center'},
-                            {display: 'active', name : 'Isactive', width : 30, sortable : true, align: 'center'},
+            colModel : [
+							// Rearrange table into something more helpful.
+							{display: 'serial number', name : 'TokenSerialnumber', width : 100, sortable : true, align: 'center'},
+                            {display: 'type', name : 'TokenType', width : 50, sortable : true, align: 'center'},
+							{display: 'description', name : 'TokenDesc', width : 200, sortable : true, align: 'center'},
+                            {display: 'active', name : 'Isactive', width : 35, sortable : true, align: 'center'},
+
                             {display: 'username', name : 'Username', width : 100, sortable : false, align: 'center'},
                             {display: 'realm', name : 'realm', width : 100, sortable : false, align: 'center'},
-                            {display: 'type', name : 'TokenType', width : 50, sortable : true, align: 'center'},
-                            {display: 'counter login', name : 'FailCount', width : 30, sortable : true, align: 'center'},
-                            {display: 'description', name : 'TokenDesc', width : 100, sortable : true, align: 'center'},
-                            {display: 'maxfailcount', name : 'maxfailcount', width : 50, sortable : false, align: 'center'},
+                            {display: 'resolver', name : 'IdResolver', width : 200, sortable : true, align: 'center'},
+							{display: 'userid', name : 'Userid', width : 100, sortable : true, align: 'center'},
+
+                            {display: 'fail count', name : 'FailCount', width : 60, sortable : true, align: 'center'},
+                            {display: 'max fails', name : 'maxfailcount', width : 60, sortable : false, align: 'center'},
                             {display: 'otplen', name : 'otplen', width : 50, sortable : false, align: 'center'},
                             {display: 'countwindow', name : 'countwindow', width : 50, sortable : false, align: 'center'},
-                            {display: 'syncwindow', name : 'syncwindow', width : 50, sortable : false, align: 'center'},
-                            {display: 'userid', name : 'Userid', width : 100, sortable : true, align: 'center'},
-                            {display: 'resolver', name : 'IdResolver', width : 200, sortable : true, align: 'center'}
-                                ],
+                            {display: 'syncwindow', name : 'syncwindow', width : 50, sortable : false, align: 'center'}
+            ],
             height: 400,
             searchitems : [
                 {display: 'in loginname', name: 'loginname', isdefault: true },
@@ -4574,26 +4783,23 @@
             url : '/manage/userview_flexi?session='+getsession(),
             method: 'GET',
             dataType : 'json',
-            colModel : [ {display: 'username', name : 'username', width : 90, sortable : true, align:"left"},
-                        {display: 'useridresolver', name : 'useridresolver', width : 200, sortable : true, align:"left"},
-            {display: 'surname', name : 'surname', width : 100, sortable : true, align:"left"},
-            {display: 'givenname', name : 'givenname', width : 100, sortable : true, align:"left"},
-            {display: 'email', name : 'email', width : 100, sortable : false, align:"left"},
-                        {display: 'mobile', name : 'mobile', width : 50, sortable : true, align:"left"},
-            {display: 'phone', name : 'phone', width : 50, sortable : false, align:"left"},
-                        {display: 'userid', name : 'userid', width : 200, sortable : true, align:"left"}
+            colModel : [
+				// Rearrange table into something more helpful.
+				{display: 'username', name : 'username', width : 100, sortable : true, align:"left"},
+				{display: 'givenname', name : 'givenname', width : 150, sortable : true, align:"left"},
+				{display: 'surname', name : 'surname', width : 150, sortable : true, align:"left"},
+				{display: 'email', name : 'email', width : 300, sortable : false, align:"left"},
+                {display: 'userid', name : 'userid', width : 100, sortable : true, align:"left"},
+				{display: 'useridresolver', name : 'useridresolver', width : 200, sortable : true, align:"left"}
             ],
             height: 400,
             searchitems : [
                 {display: 'in username          ', name : 'username', isdefault: true},
-                {display: 'surname          ', name : 'surname'},
                 {display: 'given name           ', name : 'givenname'},
-                {display: 'description          ', name : 'description'},
+				{display: 'surname          ', name : 'surname'},
+			    {display: 'email            ', name : 'email'},
                 {display: 'userid           ', name : 'userid'},
-                {display: 'email            ', name : 'email'},
-                {display: 'mobile           ', name : 'mobile'},
-                {display: 'phone            ', name : 'phone'}
-                ],
+            ],
             rpOptions: [15,20,50,100],
             sortname: "username",
             sortorder: "asc",
--- a/linotp/public/js/selfservice.js
+++ b/linotp/public/js/selfservice.js
@@ -351,7 +351,7 @@
     } finally {
         hide_waiting();
         showTokenlist();
-    }
+    }
 
     return false;
 
@@ -525,10 +525,12 @@
     }, function(data, textStatus, XMLHttpRequest) {
         hide_waiting();
         if (data.result.status == false) {
-            alert("Error deleting Token");
+            $('#del_error').show();
+			$('#del_success').hide();
         };
         if (data.result.status == true) {
-            alert("Token deleted successfully");
+            $('#del_error').hide();
+			$('#del_success').show();
             showTokenlist();
             $('.selectedToken').val("");
         };
@@ -643,11 +645,6 @@
 
 }
 
-
-
-
-
-
 function provisionGoogle() {
     show_waiting();
     var type = "googleauthenticator";
@@ -679,28 +676,33 @@
 
 function setpin() {
     show_waiting();
+	var pin0 = $('#pin0').val();
     var pin1 = $('#pin1').val();
     var pin2 = $('#pin2').val();
     var serial = $('.selectedToken').val();
-    var setpin_failed = $('#setpin_fail').val();
-    var setpin_error = $('#setpin_error').val();
-    var setpin_ok = $('#setpin_ok').val();
 
     if (pin1 != pin2) {
-        alert(setpin_failed);
+		$('#setpin_error').show();
+		$('#setpin_success').hide();
+		$('#setpin_error').text("Your PIN codes must match.");
+
         hide_waiting();
     } else {
         $.post('/selfservice/usersetpin', {
+			oldpin: pin0,
             userpin : pin1,
             serial : serial,
             session : get_selfservice_session()
         }, function(data, textStatus, XMLHttpRequest) {
             hide_waiting();
             if (data.result.status == false) {
-                alert(setpin_error + data.result.error.message);
+				$('#setpin_success').hide();
+				$('#setpin_error').show();
+				$('#setpin_error').text("There was an error updating your PIN: '" + data.result.error.message + "'. Please refresh the page and try again.");
             };
             if (data.result.status == true) {
-                alert(setpin_ok);
+                $('#setpin_success').show();
+				$('#setpin_error').hide();
                 $('#pin1').val("");
                 $('#pin2').val("");
             };
@@ -804,7 +806,6 @@
                 }
             }
         },
-        collapsible : true,
         spinner : 'Retrieving data...',
         cache : true
     });
@@ -899,3 +900,72 @@
             addTitleToCell: true
     });
 }
+
+function elmProvision() {
+    show_waiting();
+
+	var pin1 = $('#elm_pin1').val();
+    var pin2 = $('#elm_pin2').val();
+
+    if (pin1 != pin2) {
+		$('#error_pin').text("PIN codes must match.");
+        hide_waiting();
+    } else {
+        $.post('/selfservice/userwebprovision', {
+			userpin : pin1,
+			type : 'elm_totp',
+            session : get_selfservice_session()
+        }, function(data, textStatus, XMLHttpRequest) {
+            hide_waiting();
+            if (data.result.status == false) {
+				$('#error_pin').text("Error assigning token: " + data.result.error.message);
+            };
+			if (data.result.status == true) {
+				showTokenlist();
+				// The token was successfully initialized and we will display the url
+                var url = data.result.value.oathtoken.url;
+                var img = data.result.value.oathtoken.img;
+                $('#google_link').attr("href", url);
+                $('#google_qr_code').html(img);
+				$('#provisionElmInstall').hide();
+                $('#provisionElmResultDiv').show();
+
+				// Store the token's serial number for now. We send it back to the server in the next step.
+				$('#token_serial').val(data.result.value.oathtoken.serial);
+
+				// Regenerate the now-visible accordion so it's got the right height (it defaults to 0 if it's initialized while hidden)
+				$('#accordion').accordion('refresh');
+
+				// Disable the previous submit button. Otherwise, hitting enter tries to register another token for some reason.
+				$('#elmprovision').attr('disabled', 'disabled');
+			}
+        });
+    }
+}
+
+function elmProvisionFinal() {
+    show_waiting();
+
+	var otp = $('#otp').val();
+	var serial = $('#token_serial').val();
+
+    $.post('/selfservice/userelmfinal', {
+		otp: otp,
+		serial: serial,
+        session : get_selfservice_session()
+    },  function(data, textStatus, XMLHttpRequest) {
+		hide_waiting();
+        if (data.result.status == false) {
+			$('#error_otp').text("Error activating token: " + data.result.error + ". Please try again.");
+        }
+		else if (data.result.value.success == false) {
+			$('#error_otp').text("Error activating token: " + data.result.value.error + ". Please try again.");
+		}
+		else {
+				showTokenlist();
+				$('#provisionElmInstall').hide();
+				$('#provisionElmResultDiv').hide();
+				$('#provisionElmComplete').show();
+		};
+    });
+}
--- /dev/null
+++ b/linotp/public/manage/custom-style.css
@@ -0,0 +1,147 @@
+ a {
+ 	color: #3277AE;
+ }
+ 
+  body {
+	font-family: Helvetica Neue, Helvetica, Verdana,Arial,sans-serif; 
+	font-size: 1.0em;
+ }
+  
+ #header #logo {
+	margin: 0;
+	
+}
+ 
+ #logo div{
+	background-image:  url(/images/crest.png);
+	background-size: cover;
+	float: right;
+	width: 220px;
+	height: 68px;
+	margin: 0px;
+}
+ 
+ #wrap {
+	 width: 95%;
+	 position: relative;
+ }
+ 
+ #header {
+	background:#002147;
+	background-image: inherit;
+	margin: 0;
+	margin-bottom: 1em;
+	padding: 1em;
+	border: 1px solid #dedede;
+	border-radius: 0;
+	height:70px;
+	width: auto;
+	width: initial;
+	font-size: large;
+	float: none;
+}
+
+#header .sf-menu {
+	width: 100%;
+}
+
+ #main {
+	 padding: 3px;
+	 background: #eeeeee;
+	 border: 1px solid #aeaeae
+ }
+
+ #sidebar {
+	width:12%;
+	background:#eeeeee;
+	border: 1px solid #aeaeae;
+ }
+ 
+ .sf-menu > li {
+	height: 70px;
+	padding: 0 !important;
+ }
+ 
+ #menu.sf-menu > li > a {
+	border-top: none;
+	padding: 0;
+	padding-right: 2.25em;
+	padding-left: 1em;
+	color: #fff;
+ }
+  
+ #menu.sf-menu > li:hover > a { color: #3277AE; }
+ 
+ #menu.sf-menu > li > ul > li > a {
+	padding: .75em 1em;
+ }
+
+  
+ .float_left{
+ 	float: left;
+	text-align: left;
+	color: #fff;
+	font-weight: normal;
+	margin-right: 1.5em !important;
+ }
+ 
+ .float_left:hover {
+	background: #002147;
+ }
+
+ .portalname{
+	font-size:200%;
+	text-shadow:black 3px 2px 4px;
+	line-height: normal;
+
+ }
+ 
+ .sf-menu a.sf-with-ul {
+	color: #fff;
+	border-left: none;
+	font-family: Helvetica Neue, Helvetica, Verdana, sans-serif;
+	display: table-cell;
+	vertical-align: middle;
+	height: 70px;
+	padding: 0;
+ }
+ 
+ .sf-menu li li {
+	height: 2em;
+ }
+
+ 
+.ui-button {
+	border-radius: 0 !important;
+	font-family: Helvetica Neue, Helvetica, verdana, sans-serif !important;
+}
+
+#main > div > div > .ui-button {
+	margin-bottom: 1em;
+}
+
+.ui-widget {
+	font-family: Helvetica Neue, Helvetica, verdana, sans-serif !important;
+}
+
+ .ui-tabs.ui-widget {
+	border: none;
+	border-radius: 0;
+}
+
+.ui-corner-all {
+	border-radius: 0 !important;
+}
+
+.ui-state-default.ui-corner-top {
+	border-radius: 0;
+}
+
+.ui-tabs-nav.ui-widget-header {
+	background: #002147;
+	border-radius: 0;
+}
+
+#menu > li:nth-child(1):hover {
+	background: #002147;
+}
\ No newline at end of file
--- /dev/null
+++ b/linotp/public/selfservice/custom-style.css
@@ -0,0 +1,77 @@
+a {
+ 	color: #3277AE;
+}
+
+h1 {
+	color: #3277AE;
+}
+
+body {
+	font-family: Helvetica Neue, helvetica, impact, sans-serif;
+}
+	
+a.activeToken {
+	color: #3277AE;
+	text-decoration: underline;
+}
+
+.form-help {
+	color: #777777;
+	font-style: italic;
+}
+
+#main {
+	background: #eeeeee;
+	border: 1px solid #aeaeae;
+	margin-bottom: 1em;
+}
+
+#sidebar {
+	border: 1px solid #aeaeae;
+}
+
+#header {
+	background:#002147;
+	background-image: inherit;
+	margin: 0;
+	margin-bottom: 1em;
+	padding: 1em;
+	border: 1px solid #dedede;
+}
+
+#logo{
+	background-image:  url(/images/crest.png);
+	background-size: cover;
+	float: right;
+	width: 220px;
+	margin: 0px;
+}
+
+ #logout {
+	color: #3277AE;
+ }
+ 
+ #error_pin, #error_otp, #error {
+	color: #FF0000;
+ }
+ 
+/* float the logo left and the title right to match the admin page */
+ .float_right{
+	color: #fff;
+ 	float: left;
+	text-align: left;
+ }
+
+.ui-tabs.ui-widget {
+	border: none;
+	border-radius: 0;
+}
+
+.ui-state-default.ui-corner-top {
+	border-radius: 0;
+}
+
+.ui-tabs-nav.ui-widget-header {
+	background: #002147;
+	border-radius: 0;
+}
\ No newline at end of file
--- a/linotp/templates/manage/manage-base.mako
+++ b/linotp/templates/manage/manage-base.mako
@@ -65,7 +65,13 @@
 <div id="wrap">
 <div id="header" class="ui-widget-header ui-corner-all">
     <ul id='menu' class='sf-menu sf-vertical'>
-        <li><a href='#'>${_("LinOTP Config")}</a>
+		<li>
+				<div class="float_left">
+				Elm Authentication System<br>
+				<span class=portalname>${_("Management Portal")}</span>
+				</div>
+		</li>
+		<li><a href='#'>${_("LinOTP Config")}</a>
             <ul>
                 <li><a href='#' id='menu_edit_resolvers'>${_("useridresolvers")}</a></li>
                 <li><a href='#' id='menu_edit_realms'>${_("realms")}</a></li>
@@ -102,8 +108,8 @@
                 <li><a href='#' id='menu_about'>${_("About LinOTP")}</a></li>
             </ul>
         </li>
+		<li id="logo"><div></div></li>
     </ul>
-    <div id="logo"><img src="/images/linotp_logo_118x40.png" alt="LinOTP"/></div>
 </div> <!-- header -->
 <div class="javascript_error" id="javascript_error">
 	${_("You need to enable Javascript to use the LinOTP Management Web UI.")}
@@ -119,9 +125,12 @@
     <div id="selected_tokens"></div>
     <span id="selected_users_header">${_("selected users")}</span>
     <div id="selected_users"></div>
-    <p>${_("Logged in as")}: ${c.admin}
-        <a href="${c.logout_url}">${_("Logout")}</a>
+    <p>
+		User: ${c.login}<br/>
+		Realm: ${c.realm}</br>
+		<a id="logout_url" href="${c.logout_url}">${_("Logout")}</a>
     </p>
+
     <div id="realms">
     ${_("Realms")}: <select id=realm></select>
     </div>
@@ -401,12 +410,19 @@
 	    		<option value="ocra">OCRA PIN</option>
 	    		<option selected value="otp">OTP PIN</option>
 	    		</select>
-	    		</td></tr><tr><td>
+	    		</td></tr>
+				<tr><td>
+	    		<label for="pin0">Old PIN (if any)</label>
+	    		</td><td>
+	    		<input type="password" autocomplete="off" name="pin0" id="pin0" class="text ui-widget-content ui-corner-all"/>
+	    		</td></tr>
+				<tr><td>
+				<tr><td>
 	    		<label for="pin1">PIN</label>
 	    		</td><td>
-	    		<input type="password" autocomplete="off" onkeyup="checkpins('pin1','pin2');" name="pin1" id="pin1"
-	    			class="text ui-widget-content ui-corner-all" />
-	    		</td></tr><tr><td>
+	    		<input type="password" autocomplete="off" name="pin1" id="pin1" class="text ui-widget-content ui-corner-all" />
+	    		</td></tr>
+				<tr><td>
 	    		<label for="pin2">${_("PIN (again)")}</label>
 	    		</td><td>
 	    		<input type="password" autocomplete="off" onkeyup="checkpins('pin1','pin2');" name="pin2" id="pin2" class="text ui-widget-content ui-corner-all" />
@@ -884,6 +900,7 @@
 		$('#button_new_resolver_type_ldap .ui-button-text').html('${_("LDAP")}');
 		$('#button_new_resolver_type_sql .ui-button-text').html('${_("SQL")}');
 		$('#button_new_resolver_type_flatfile .ui-button-text').html('${_("Flatfile")}');
+		$('#button_new_resolver_type_oak .ui-button-text').html('${_("Oak")}');
 		$('#button_new_resolver_type_cancel .ui-button-text').html('${_("Cancel")}');
 	}
 </script>
@@ -1269,6 +1286,57 @@
 	}
 </script>
 
+<!-- ################## dialog Oak resolver ######################### -->
+
+<div id="dialog_oak_resolver">
+	<form class="cmxform" id="form_oakconfig">
+		<fieldset name='${_("Oak configuration")}'>
+			<table>
+				<tr>
+					<td><label for=oak_resolvername>${_("Resolver name")}:</label></td>
+					<td><input type="text" name="oak_resolvername" class="required"  id="oak_resolvername" size="35" maxlength="20"></td>
+				</tr>
+				<tr>
+					<td><label for=oak_realm>${_("Realm code (eg 'ball' or 'admn')")}:</label></td>
+					<td><input type="text" name="oak_realm" class="required"  id="oak_realm" size="20" maxlength="20"></td>
+				</tr>
+				<tr>
+					<td><label for=oak_sizelimit>${_("Response size limit")}:</label></td>
+					<td><input type="text" name="oak_sizelimit" class="required"  id="oak_sizelimit" size="10" maxlength="10"></td>
+				</tr>
+				<tr>
+				<div id=realm_hidden>
+					<tr>
+						<td><label for=autorealm>Create matching realm:</label></td>
+						<td><input type="checkbox" name="autorealm" id="autorealm" value="autorealm" title="This will automatically create a realm linked to this resolver."></td>
+					</tr>
+					<tr id="autorealm_tr">
+						<td><label for=autorealm_name>Realm name:</label></td>
+						<td><input type="text" name="autorealm_name"  id="autorealm_name" size="20" maxlength="60" value=""></td>
+					</tr>
+				</div>
+				<input type=hidden id=is_edit value="">
+			</table>
+		</fieldset>
+	</form>
+	<div id="progress_test_oak"><img src="/images/ajax-loader.gif" border="0" alt=""> ${_("Testing connections...")} </div>
+		<button class="action-button" id="button_test_oak">${_("Test Oak connection")}</button>\
+</div>
+
+<script>
+	$('#autorealm_tr').hide();
+	$('#autorealm').change(function() {
+		if ($(this)[0].checked)
+			$('#autorealm_tr').show();
+		else
+			$('#autorealm_tr').hide();
+    });
+	function translate_dialog_oak_resolver() {
+		$("#dialog_oak_resolver" ).dialog( "option", "title", '${_("Oak Resolver")}' );
+		$('#button_test_oak .ui-button-text').html('${_("Test Oak connection")}');
+	}
+</script>
+
 <!-- #################### dialog SQL resolver #################################### -->
 
 <div id='dialog_sql_resolver'>
@@ -1368,6 +1436,8 @@
 <div id="text_subscription_import_failed">${_("Failed to load support subscription")}: <span class="text_param1"> </span></div>
 <div id="text_subscription_import_result">${_("Support subscription import result")}: <span class="text_param1"> </span></div>
 <div id="text_error_ldap">${_("Error saving ldap configuration.")}: <span class="text_param1"> </span></div>
+<div id="text_error_oak">${_("Error saving Oak configuration.")}: <span class="text_param1"> </span></div>
+
 <div id="text_error_realm">${_("Error saving realm configuration.")}: <span class="text_param1"> </span></div>
 <div id="text_realm_created">${_("Realm created")}: <span class="text_param1"> </span></div>
 <div id="text_error_set_realm">${_("Error setting Token realms")}: <span class="text_param1"> </span></div>
@@ -1380,6 +1450,10 @@
 <div id="text_regexp_error">${_("Error in regular expression for")}: <span class="text_param1"> </span></div>
 <div id="text_ldap_config_success">${_("LDAP config seems to be OK! Number of users found")}: <span class="text_param1"> </span></div>
 <div id="text_ldap_load_error">${_("Error loading LDAP resolver")}: <span class="text_param1"> </span></div>
+
+<div id="text_oak_config_success">${_("Oak config seems to be OK! Number of users found")}: <span class="text_param1"> </span></div>
+<div id="text_oak_load_error">${_("Error loading Oak resolver")}: <span class="text_param1"> </span></div>
+
 <div id="text_sql_load_error">${_("Error loading SQL resolver")}: <span class="text_param1"> </span></div>
 <div id="text_sql_config_success">${_("SQL config seems to be OK! Number of users found")}: <span class="text_param1"> </span></div>
 <div id="text_sql_config_fail">${_("SQL config contains errors")}: <span class="text_param1"> </span></div>
--- a/linotp/templates/manage/policies.mako
+++ b/linotp/templates/manage/policies.mako
@@ -25,9 +25,9 @@
  *    Support: www.lsexperts.de
  *
 -->
-<a id=policy_export>${_("Export policies")}</a>
+<button class='ui-button' id=policy_export>${_("Export policies")}</button>
 
-<button id=policy_import>${_("Import policies")}</button>
+<button class='ui-button' id=policy_import>${_("Import policies")}</button>
 
 <table id="policy_table" class="flexme2" style="display:none"></table>
    
--- a/linotp/templates/selfservice/base.mako
+++ b/linotp/templates/selfservice/base.mako
@@ -66,7 +66,7 @@
 	</div>
 
 	<div class="float_right">
-	Open Source Edition<br>
+	Elm Authentication System<br>
 	<span class=portalname>${_("Selfservice Portal")}</span>
 	</div>
 </div>
@@ -115,6 +115,10 @@
 			<li><a href="/selfservice/webprovisiongoogletoken"><span>${_("Enroll Google Authenticator")}</span></a></li>
 		%endif
 
+		% if 'webprovisionElm' in c.actions:
+			<li><a href="/selfservice/webprovisionelm"><span>${_("Activate Two-Factor Authentication")}</span></a></li>
+		%endif
+
 		% if 'assign' in c.actions:
 			<li><a href="/selfservice/assign"><span>${_("Assign Token")}</span></a></li>
 		%endif
@@ -131,7 +135,7 @@
 		<li><a href="/selfservice/reset"><span>${_("Reset Failcounter")}</span></a></li>
 		%endif
 		%if 'setOTPPIN' in c.actions:
-		<li><a href="/selfservice/setpin"><span>${_("set PIN")}</span></a></li>
+		<li><a href="/selfservice/setpin"><span>${_("Change Token PIN")}</span></a></li>
 		%endif
 		%if 'setMOTPPIN' in c.actions:
 		<li><a href="/selfservice/setmpin"><span>${_("set mOTP PIN")}</span></a></li>
@@ -143,7 +147,7 @@
 		<li><a href="/selfservice/unassign"><span>${_("unassign Token")}</span></a></li>
 		%endif
 		%if 'delete' in c.actions:
-		<li><a href="/selfservice/delete"><span>${_("delete Token")}</span></a></li>
+		<li><a href="/selfservice/delete"><span>${_("Delete Token")}</span></a></li>
 		%endif
 		%if 'history' in c.actions:
 		<li><a href="/selfservice/history"><span>${_("History")}</span></a></li>
--- a/linotp/lib/policy.py
+++ b/linotp/lib/policy.py
@@ -152,6 +152,7 @@
             'webprovisionOATH': {'type': 'bool'},
             'webprovisionGOOGLE': {'type': 'bool'},
             'webprovisionGOOGLEtime': {'type': 'bool'},
+            'webprovisionElm': {'type' : 'bool'},
             'max_count_dpw': {'type': 'int'},
             'max_count_hotp': {'type': 'int'},
             'max_count_totp': {'type': 'int'},
@@ -667,8 +668,7 @@
 
     # We may change this later to other authetnication schemes
     admin_user = getUserFromRequest(request)
-    log.info("[getAdminPolicies] Evaluating policies for the "
-             "user: %s" % admin_user['login'])
+    log.info("[getAdminPolicies] Evaluating policies for user %s" % admin_user['login'])
     pol_request = {'user': admin_user['login'], 'scope': 'admin'}
     if '' != action:
         pol_request['action'] = action
@@ -2016,12 +2016,15 @@
         elif 'userwebprovision' == method:
             user_selfservice_actions = getSelfserviceActions(authUser)
             typ = param.get('type').lower()
+            # Allow Elm provisioning.
             if ((typ == 'oathtoken'
                     and 'webprovisionOATH' not in user_selfservice_actions)
                 or (typ == 'googleauthenticator_time'and
                     'webprovisionGOOGLEtime' not in user_selfservice_actions)
                 or (typ == 'googleauthenticator'
-                    and 'webprovisionGOOGLE' not in user_selfservice_actions)):
+                    and 'webprovisionGOOGLE' not in user_selfservice_actions)
+                or (typ == "elm_totp"
+                    and "webprovisionElm" not in user_selfservice_actions)):
                 log.warning("[userwebprovision] user %r@%r is not allowed to "
                             "call this function!" % (authUser.login,
                                                      authUser.realm))
--- /dev/null
+++ b/linotp/templates/selfservice/webprovisionelm.mako
@@ -0,0 +1,117 @@
+# -*- coding: utf-8 -*-
+<!--
+ *
+ *   LinOTP - the open source solution for two factor authentication
+ *   Copyright (C) 2010 - 2014 LSE Leading Security Experts GmbH
+ *
+ *   This file is part of LinOTP server.
+ *
+ *   This program is free software: you can redistribute it and/or
+ *   modify it under the terms of the GNU Affero General Public
+ *   License, version 3, as published by the Free Software Foundation.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU Affero General Public License for more details.
+ *
+ *   You should have received a copy of the
+ *              GNU Affero General Public License
+ *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ *
+ *    E-mail: linotp@lsexperts.de
+ *    Contact: www.linotp.org
+ *    Support: www.lsexperts.de
+ *
+-->
+<h1>${_("Activate Two-Factor Authentication")}</h1>
+
+<div id='elmform'>
+	<form class="cmxform" name='myForm'> 
+		<fieldset>
+			<ol id="provisionElmInstall">
+				<li>Install the appropriate authenticator application on your mobile device:
+					<ul>
+						<li>Android, iOS or Blackberry OS 7 and earlier: <a href='http://m.google.com/authenticator' target='extern'>Google Authenticator</a></li>
+						<li>Blackberry OS 10: <a href='http://appworld.blackberry.com/webstore/content/76023/?lang=en' target='extern'>Duo Mobile</a></li>
+						<li>Windows Phone: <a href='http://go.microsoft.com/fwlink/?LinkId=279710' target='extern'>Microsoft Authenticator</a></li>
+					</ul>
+				</li>
+				<li>Choose a four-digit PIN code for the new token. Your PIN is required whenever you are asked for an access code - for example, if your PIN
+					is 1234 and your one-time-password is 000000, you would enter '1234000000'.
+					<table>
+						<tr><td><span id=error_pin></span></td></tr>
+						<tr>
+							<!--[if lte IE 9]>
+								<td><label class="ie-label" for="elm_pin1">PIN</label></td>
+							<![endif]-->
+							<td><input id="elm_pin1" autocomplete="off" type="password" placeholder="PIN" size="10" maxlength="4" tabindex="1" class="text ui-widget-content ui-corner-all"/></td>
+						</tr>
+						<tr>
+							<!--[if lte IE 9]>
+								<td><label class="ie-label" for="elm_pin2">Confirm PIN</label></td>
+							<![endif]-->						
+							<td><input id="elm_pin2" autocomplete="off" type="password" placeholder="Confirm PIN" size="10" maxlength="4" tabindex="1" onkeyup="checkpins('elm_pin1', 'elm_pin2');" class="text ui-widget-content ui-corner-all"/></td>
+						</tr>
+					</table>
+					<button class='action-button' id="elmprovision" onclick="elmProvision(); return false;">
+						${_("Activate token")}
+					</button>
+				</li>
+			</ol>
+			
+			<ol id="provisionElmResultDiv" start="3">
+				<li>${_("Token")} ${_("successfully created!")}
+					<p>${_("If you are viewing this site on the same device as your authenticator app, click the link below to activate your code:")}
+						 <a id=google_link>${_("Install token")}</a>
+					</p>
+					<p>${_("Alternatively, scan the QR code below with your authenticator device.")}</p>
+					<div id="accordion">
+						<h3>QR Code</h3>
+						<div>
+							<span id=google_qr_code></span>
+						</div>
+					</div>
+				</li>
+				<li>Enter your PIN followed by a one-time password generated by your authenticator app to complete setup. For example, if your PIN
+					is 1234 and your one-time-password is 000000, you would enter '1234000000'. Note that your authenticator <strong>will not work</strong>
+					on Single Sign On pages until you complete this step.
+					<table>
+						<tr><td><span id=error_otp></span></td></tr>
+						<tr>
+							<!--[if lte IE 9]>
+								<td><label class="ie-label" for="otp">Access Code</label></td>
+							<![endif]-->
+							<td><input id="otp" autocomplete="off" type="password" placeholder="Access Code" size="10" maxlength="10" tabindex="1" class="text ui-widget-content ui-corner-all"/></td>
+						</tr>
+					</table>
+					<button class='action-button' id="elmfinal" onclick="elmProvisionFinal(); return false;">
+						${_("Finish installation")}
+					</button>
+					<input type=hidden id=token_serial value="">
+				</li>
+			</ol>
+			<div id="provisionElmComplete">
+				<p>Your token has now been activated. Single Sign-On pages will now prompt you for an access code when you attempt to login.</p>
+			</div>
+		</fieldset>
+		
+	</form>
+</div>
+
+<script>
+		// Initial display.
+		$('#provisionElmInstall').show();
+	   	$('#provisionElmResultDiv').hide();
+		$('#provisionElmComplete').hide();
+
+		// Set up the accordion drop-down for the QR codes.
+		$(function() {
+			$("#accordion").accordion({
+				'collapsible' : true,
+				'active' : false
+			});
+		});
+
+</script>
--- a/linotp/templates/selfservice/delete.mako
+++ b/linotp/templates/selfservice/delete.mako
@@ -25,18 +25,32 @@
  *    Support: www.lsexperts.de
  *
 -->
-<h1>${_("Delete OTP Token")}</h1>
+<h1>${_("Delete Token")}</h1>
 
 <div id='deleteform'>
 	<form class="cmxform" name='myForm'>
 		<fieldset>
-		<table>
-		<tr>
-		<td>${_("selected Token")}</td>
-		<td><input type='text' class='selectedToken'  class="text ui-widget-content ui-corner-all" disabled value='' /></td>
-		</tr>
-		</table>
-		<button class='action-button' id='button_delete' onclick="token_delete(); return false;">${_("delete Token")}</button>
+			<span id=del_error>There was an error deleting your token. Please refresh the page and try again.</span>
+			<span id=del_success>Your token has been deleted. If this was your last token, the Single Sign On service will no longer ask for an access code when you login. You will also be unable to access secure resources that require two-factor authentication: to retain access to these services, you should create a new token.</span>
+
+			<p>This page allows you to delete a token. Your authenticator app will continue to generate codes, but they will no longer be accepted by the Single Sign On service.</p>
+			<p>If all of your tokens are deleted, the Single Sign On service will no longer ask for an access code when you login. You will also be unable to access secure resources that require two-factor authentication: to retain access to these services, you should create a new token.</p>
+			<table>
+				<tr>
+					<!--[if lte IE 9]>
+						<td><label class="ie-label" for="selectedToken">Token</label></td>
+					<![endif]-->
+					<td><input id="selectedToken" type='text' class='selectedToken' class="text ui-widget-content ui-corner-all" disabled value='' placeholder="Token"/>
+					<td><span class="form-help">Click a token on the left to select it.</span></td>
+				</tr>
+			</table>
+			<button class='action-button' id='button_delete' onclick="token_delete(); return false;">${_("Delete Token")}</button>
 		</fieldset>
 	</form>
 </div>
+
+<script>
+		// Initial display.
+	   	$('#del_success').hide();
+		$('#del_error').hide();
+</script>
--- a/linotp/templates/selfservice/setpin.mako
+++ b/linotp/templates/selfservice/setpin.mako
@@ -25,30 +25,54 @@
  *    Support: www.lsexperts.de
  *
 -->
-<h1>${_("Reset OTP PIN")}</h1>
+<h1>${_("Change Token PIN")}</h1>
 
 <div id='passwordform'>
 	<form class="cmxform" name='myForm'>
 		<fieldset>
-	
-		<table>
-		<tr>
-		<td>${_("selected Token")}</td>
-		<td><input type='text' class='selectedToken' class="text ui-widget-content ui-corner-all" disabled value='' /></td>
-		</tr>
-		<tr>
-		<td><label for=pin1>PIN</label></td>
-		<td><input autocomplete="off" type='password' onkeyup="checkpins('pin1', 'pin2');" id='pin1' class="text ui-widget-content ui-corner-all" value='' /></td>
-		</tr>
-		<tr>
-		<td><label for=pin2>${_("repeat PIN")}</label></td>
-		<td><input autocomplete="off" type='password' onkeyup="checkpins('pin1', 'pin2');" id='pin2' class="text ui-widget-content ui-corner-all" value=''/></td>
-  		</tr>
-		</table>
-		<button class='action-button' id='button_setpin' onclick="setpin(); return false;">${_("set PIN")}</button>
-	<input type='hidden' value='${_("The passwords do not match!")}' 		id='setpin_fail'/>
-		<input type='hidden' value='${_("Error setting PIN: ")}' 			id='setpin_error'/>
-		<input type='hidden' value='${_("PIN set successfully")}'			id='setpin_ok'/>
+			<span id=setpin_error></span>
+			<span id=setpin_success>Your PIN was updated successfully.</span>
+
+			<p>This page allows you to change the PIN associated with a token. Once you update your PIN, you should use the new PIN when logging in to Single Sign On services.</p>
+			<p>Note that the PIN for each token is independent. If you have multiple tokens, this page will only update the PIN for the selected token - you should repeat the process for your other tokens if you wish to change their PINs as well.</p>
+
+			<p>If you do not know your current PIN, you should contact your College or department IT staff for assistance. </p>
+			<table>
+				<tr>
+					<!--[if lte IE 9]>
+						<td><label class="ie-label" for="selectedToken">Token</label></td>
+					<![endif]-->
+					<td><input id="selectedToken" type='text' class='selectedToken' class="text ui-widget-content ui-corner-all" disabled value='' placeholder="Token"/>
+					<td><span class="form-help">Click a token on the left to select it.</span></td>
+				</tr>
+				<tr>
+					<!--[if lte IE 9]>
+						<td><label class="ie-label" for="pin0">Current PIN</label></td>
+					<![endif]-->
+					<td><input autocomplete="off" type='password' id="pin0" class="text ui-widget-content ui-corner-all" value='' placeholder="Current PIN"/></td>
+				</tr>
+				<tr>
+					<!--[if lte IE 9]>
+						<td><label class="ie-label" for="pin1">New PIN</label></td>
+					<![endif]-->
+					<td><input autocomplete="off" type='password' id="pin1" class="text ui-widget-content ui-corner-all" value='' placeholder="New PIN"/></td>
+				</tr>
+				<tr>
+					<!--[if lte IE 9]>
+						<td><label class="ie-label" for="pin1">Confirm new PIN</label></td>
+					<![endif]-->
+
+					<td><input autocomplete="off" type='password' onkeyup="checkpins('pin1', 'pin2');" id="pin2" class="text ui-widget-content ui-corner-all" value='' placeholder="Confirm new PIN"/></td>
+				</tr>
+			</table>
+			<button class='action-button' id='button_setpin' onclick="setpin(); return false;">${_("set PIN")}</button>
+
 		</fieldset>
 	</form>
 </div>
+
+<script>
+		// Initial display.
+	   	$('#setpin_success').hide();
+		$('#setpin_error').hide();
+</script>
\ No newline at end of file
--- /dev/null
+++ b/config/linotp2-elm
@@ -0,0 +1,142 @@
+<VirtualHost _default_:443>
+	ServerAdmin webmaster@localhost
+
+	Header always edit Set-Cookie ^(.*)$ $1;secure
+
+	DocumentRoot /var/www
+	<Directory />
+		Options FollowSymLinks
+		AllowOverride None
+	</Directory>
+	<Directory /var/www/>
+		Options Indexes FollowSymLinks MultiViews
+		AllowOverride None
+		Order allow,deny
+		allow from all
+	</Directory>
+
+    Alias /doc/html         /usr/share/doc/linotpdoc/html
+   	WSGIScriptAlias /       /etc/linotp2/linotpapp.wsgi
+	#
+	# The daemon is running as user 'linotp'
+	# This user should have access to the encKey database encryption file
+	WSGIDaemonProcess linotp processes=1 threads=15 display-name=%{GROUP} user=linotp
+	WSGIProcessGroup linotp
+    WSGIPassAuthorization On
+
+    <Location /admin>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+		WebAuthRequireInitialFactor p m o3
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+
+	<Location /audit>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+		WebAuthRequireInitialFactor p m o3
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+	<Location /gettoken>
+		AuthType Digest
+		AuthName "LinOTP2 gettoken"
+		AuthDigestProvider file
+		AuthUserFile /etc/linotp2/gettoken-api
+		Require valid-user
+	</Location>
+
+	<Location /manage>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+		WebAuthRequireInitialFactor p m o3
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+    <Location /system>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+		WebAuthRequireInitialFactor p m o3
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+	<Location /selfservice>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+	<Location /account>
+        Order deny,allow
+        Deny from all
+        Allow from localhost
+        Satisfy Any
+
+        WebAuthExtraRedirect on
+        AuthType WebAuth
+        require valid-user
+    </Location>
+
+	<Location /account/logout>
+		WebAuthDoLogout on
+	</Location>
+
+    <Location /validate>
+	    # No Authentication
+    </Location>
+
+
+	ErrorLog /var/log/apache2/error.log
+
+	LogLevel warn
+
+	# Do not use %q! This will reveal all parameters, including setting PINs and Keys!
+	# Using SSL_CLINET_S_DN_CN will show you, which administrator did what task
+	LogFormat "%h %l %u %t %>s \"%m %U %H\"  %b \"%{Referer}i\" \"%{User-agent}i\" \"%{SSL_CLIENT_S_DN_CN}x\"" LinOTP2
+	CustomLog /var/log/apache2/ssl_access.log LinOTP2
+
+	#   SSL Engine Switch:
+	#   Enable/Disable SSL for this virtual host.
+	SSLEngine on
+
+	#   If both key and certificate are stored in the same file, only the
+	#   SSLCertificateFile directive is needed.
+	SSLCertificateFile    /etc/ssl/certs/linotpserver.pem
+	SSLCertificateKeyFile /etc/ssl/private/linotpserver.key
+
+	<FilesMatch "\.(cgi|shtml|phtml|php)$">
+	SSLOptions +StdEnvVars
+	</FilesMatch>
+	<Directory /usr/lib/cgi-bin>
+		SSLOptions +StdEnvVars
+	</Directory>
+
+    ErrorDocument 500 "<h1>Internal Server Error</h1> Possible reasons can be missing modules or bad access rights on LinOTP configuration files or log files. Please check the apache logfile <pre>/var/log/apache2/error.log</pre> for more details."
+
+</VirtualHost>
--- a/linotp/lib/selfservice.py
+++ b/linotp/lib/selfservice.py
@@ -47,7 +47,6 @@
         res = f.read()
         f.close()
     except Exception as e:
-        log.info("[get_imprint] can not read imprint file: %s. (%r)"
-                 % (filename, e))
+        log.debug("[get_imprint] can not read imprint file: %s. (%r)" % (filename, e))
 
     return res
--- a/linotp/lib/ImportOTP/vasco.py
+++ b/linotp/lib/ImportOTP/vasco.py
@@ -40,7 +40,7 @@
     vasco_lib = config.get("linotpImport.vasco_dll")
     #/opt/vasco/Vacman_Controller-3.10.1/lib/libaal2sdk-3.10.1.so
     if None == vasco_lib:
-        log.warning("Missing linotpImport.vasco_dll in config file")
+        log.info("Missing linotpImport.vasco_dll parameter in config file.")
     else:
         log.info("loading vasco lib %s" % vasco_lib)
         vasco_dll = CDLL(vasco_lib)
@@ -56,7 +56,7 @@
     '''
     def new(*args, **kw):
         if None == vasco_dll:
-            log.error("[check_vasco] No vasco dll available!")
+            log.warning("[check_vasco] No vasco dll found. Vasco functions will not be available.")
             return None
         else:
             return fn(*args, **kw)
--- a/linotp/lib/audit/SQLAudit.py
+++ b/linotp/lib/audit/SQLAudit.py
@@ -271,7 +271,7 @@
             column.create(audit_table)
         except Exception as exx:
             # Obviously we already migrated the database.
-            log.info("[__init__] Error during database migration: %r" % exx)
+            log.info("[__init__] Assuming database migration is complete: %r" % exx)
 
 
     def _attr_to_dict(self, audit_line):
--- a/linotp/lib/crypt.py
+++ b/linotp/lib/crypt.py
@@ -97,11 +97,14 @@
 
 
 class SecretObj:
-    def __init__(self, val, iv, preserve=True):
+    def __init__(self, val, iv, preserve=True, pin=None):
         self.val = val
         self.iv = iv
         self.bkey = None
         self.preserve = preserve
+        # IVs are xored with the PIN for Elm tokens.
+        if (pin is not None):
+            self.iv = xor_crypt(self.iv, pin)
 
     def getKey(self):
         log.warn('Requesting secret key '
@@ -151,7 +154,9 @@
             self.bkey = None
 
         if self.bkey is None:
+            import traceback
             akey = decrypt(self.val, self.iv)
+
             self.bkey = binascii.unhexlify(akey)
             zerome(akey)
             del akey
@@ -657,4 +662,18 @@
     #print repr(bufferObject)
     return
 
-##eof##########################################################################
+# Get a binascii.unhexlified message, return a XOR-crypted / decrypted hex message.
+def xor_crypt(message, key):
+    res = []
+    k = bytearray(binascii.unhexlify(key))
+    l = len(k);
+    i = 0;
+
+    for b in bytearray(message):
+        res.append(b ^ k[i])
+        i = (i + 1) % l
+
+    result = binascii.hexlify(bytearray(res))
+    return binascii.unhexlify(result);
+
+##eof##########################################################################
\ No newline at end of file
--- a/linotp/lib/tokenclass.py
+++ b/linotp/lib/tokenclass.py
@@ -223,7 +223,7 @@
         if res != -1:
             pin_match = check_pin(self, pin, user=user, options=options)
             if pin_match is True:
-                otp_counter = check_otp(self, otpval, options=options)
+                otp_counter = check_otp(self, otpval, options=options, pin=pin)
 
         return (pin_match, otp_counter, reply)
 
@@ -690,7 +690,9 @@
         if enc is not None and "true" == enc.lower():
             storeHashed = False
 
-        self.token.setPin(pin, storeHashed)
+        oldpin = getParam(param, "oldpin", optional)
+
+        self.token.setPin(pin, storeHashed, oldpin)
 
     def getPinHashSeed(self):
         return self.token.LinOtpPinHash, self.token.LinOtpSeed
@@ -1681,7 +1683,7 @@
         return (transid, challenge, True, url)
 
 
-    def checkOtp(self, passw , counter , window , options=None):
+    def checkOtp(self, passw , counter , window , options=None, pin=None):
         '''
         checkOtp - standard callback of linotp to verify the token
 
@@ -1703,7 +1705,8 @@
 
         ret = -1
 
-        secretHOtp = self.token.getHOtpKey()
+        # Pass any PIN we might have got onwards.
+        secretHOtp = self.token.getHOtpKey(pin=pin)
         ocraSuite = OcraSuite(self.getOcraSuiteSuite(), secretHOtp)
 
         ## if we have no transactionid given through the options,
--- a/linotp/lib/tokens/totptoken.py
+++ b/linotp/lib/tokens/totptoken.py
@@ -376,7 +376,7 @@
 
 
 
-    def checkOtp(self, anOtpVal, counter, window, options=None):
+    def checkOtp(self, anOtpVal, counter, window, options=None, pin=None):
         '''
         checkOtp - validate the token otp against a given otpvalue
 
@@ -398,7 +398,7 @@
         '''
 
         log.debug("[checkOtp] begin. Validate the token otp: anOtpVal: %r ,\
-                    counter: %r,window: %r, options: %r " %
+                    counter: %r,window: %r, options: %r" %
                     (anOtpVal, counter, window, options))
 
         try:
@@ -406,7 +406,7 @@
         except ValueError as e:
             raise e
 
-        secretHOtp = self.token.getHOtpKey()
+        secretHOtp = self.token.getHOtpKey(pin)
         self.hashlibStr = self.getFromTokenInfo("hashlib", self.hashlibStr)
 
         timeStepping = int(self.getFromTokenInfo("timeStep", self.timeStep))
@@ -444,14 +444,16 @@
         log.debug("[checkOTP] shift   : %r " % (shift))
 
         hmac2Otp = HmacOtp(secretHOtp, counter, otplen, self.getHashlib(self.hashlibStr))
+
+        log.debug("got hmac")
         res = hmac2Otp.checkOtp(anOtpVal, int (window / timeStepping), symetric=True)
 
-        log.debug("[checkOTP] comparing the result %i to the old counter %i." % (res, oCount))
+        log.warning("[checkOTP] comparing the result %i to the old counter %i." % (res, oCount))
         if res != -1 and oCount != 0 and res <= oCount:
             if initTime == -1:
                 log.warning("[checkOTP] a previous OTP value was used again!\n former tokencounter: %i, presented counter %i" %
                         (oCount, res))
-                res = -1
+                res = -2 # return something different so we can tell them their code is being reused
                 return res
 
         if -1 == res :
--- a/linotp/model/__init__.py
+++ b/linotp/model/__init__.py
@@ -57,6 +57,7 @@
 from linotp.lib.crypt import encryptPin
 from linotp.lib.crypt import decryptPin
 from linotp.lib.crypt import get_rand_digit_str
+from linotp.lib.crypt import xor_crypt
 
 
 from pylons import config
@@ -228,11 +229,11 @@
         self.LinOtpTokenPinUserIV = unicode(binascii.hexlify(iv))
 
 
-    def getHOtpKey(self):
-        log.debug('getHOtpKey()')
+    def getHOtpKey(self, pin=None):
+        log.warning('getHOtpKey()')
         key = binascii.unhexlify(self.LinOtpKeyEnc or '')
         iv = binascii.unhexlify(self.LinOtpKeyIV or '')
-        secret = SecretObj(key, iv)
+        secret = SecretObj(key, iv, pin=pin)
         return secret
 
     def getOtpCounter(self):
@@ -249,9 +250,12 @@
 
     def setHashedPin(self, pin):
         log.debug('setHashedPin()')
+
         seed = geturandom(16)
         self.LinOtpSeed = unicode(binascii.hexlify(seed))
         self.LinOtpPinHash = unicode(binascii.hexlify(hash(pin, seed)))
+
+
         return self.LinOtpPinHash
 
     def getHashedPin(self, pin):
@@ -279,13 +283,31 @@
         log.debug('setOtpLen %i' % int(otplen))
         self.LinOtpOtpLen = int(otplen)
 
-    def setPin(self, pin, hashed=True):
+    def setPin(self, pin, hashed=True, oldpin = None):
         # TODO: we could log the PIN here
         log.debug("setPin()")
 
         upin = ""
         if pin != "" and pin is not None:
             upin = pin
+
+        # For Elm, we crypt the IV with the PIN.
+        if (self.LinOtpKeyIV):
+            iv = binascii.unhexlify(self.LinOtpKeyIV)
+
+            # If we have an existing PIN hash, we need to
+            # re-encrypt the IV with the new PIN.
+            if (self.LinOtpPinHash):
+                if (oldpin):
+                    # Decrypt the IV using the old PIN.
+                    iv = xor_crypt(iv, oldpin)
+                else:
+                    # We *need* the old PIN or we can't recover the IV.
+                    raise Exception("Old PIN is required to change an existing PIN!")
+
+            # Encrypt the IV with the new PIN
+            self.LinOtpKeyIV = binascii.hexlify(xor_crypt(iv, upin))
+
         if hashed == True:
             self.setHashedPin(upin)
             log.debug("setPin(HASH:%r)" % self.LinOtpPinHash)
@@ -500,13 +522,6 @@
                 log.debug('update token OtpKey - counter reset')
                 self.setHKey(otpKey)
 
-    def updateToken(self, tokenDesc, otpKey, pin):
-        log.debug('updateToken()')
-
-        self.setDescription(tokenDesc)
-        self._setPin(pin)
-        self.updateOtpKey(otpKey)
-
     def getRealms(self):
         return self.realms or ''
 
